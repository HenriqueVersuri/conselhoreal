-- Supabase schema for Conselho Real
-- Execute this script inside the Supabase SQL editor (or via CLI) to prepare the backend.

-- EVENTS --------------------------------------------------------------------
create table if not exists public.events (
  id bigint generated by default as identity primary key,
  title text not null,
  type text not null check (type in ('Gira', 'Atendimento', 'Estudo', 'Mutir√£o')),
  date timestamptz not null,
  capacity integer not null default 0,
  attendees integer not null default 0,
  created_at timestamptz not null default now()
);

-- ANNOUNCEMENTS -------------------------------------------------------------
create table if not exists public.announcements (
  id bigint generated by default as identity primary key,
  title text not null,
  content text not null,
  created_at timestamptz not null default now()
);

-- PRAYER REQUESTS -----------------------------------------------------------
create table if not exists public.prayer_requests (
  id bigint generated by default as identity primary key,
  initials text not null,
  request text not null,
  created_at timestamptz not null default now()
);

-- GALLERY -------------------------------------------------------------------
create table if not exists public.gallery_images (
  id bigint generated by default as identity primary key,
  src text not null,
  alt text default '',
  caption text default '',
  category text not null default 'Terreiro',
  created_at timestamptz not null default now()
);

-- USERS ---------------------------------------------------------------------
create table if not exists public.users (
  id bigint generated by default as identity primary key,
  name text not null,
  email text not null unique,
  role text not null default 'MEMBRO',
  member_since date,
  allergies text,
  created_at timestamptz not null default now()
);

-- DIARY ENTRIES -------------------------------------------------------------
create table if not exists public.diary_entries (
  id bigint generated by default as identity primary key,
  user_id bigint not null references public.users(id) on delete cascade,
  title text not null,
  content text not null,
  tags text[] not null default '{}',
  due_date timestamptz,
  attachment jsonb,
  created_at timestamptz not null default now()
);

-- RECADOS -------------------------------------------------------------------
create table if not exists public.recados (
  id bigint generated by default as identity primary key,
  user_id bigint not null references public.users(id) on delete cascade,
  "from" text not null default 'Admin',
  message text not null,
  read boolean not null default false,
  created_at timestamptz not null default now()
);

-- MEMBER ENTITIES -----------------------------------------------------------
create table if not exists public.member_entities (
  id bigint generated by default as identity primary key,
  user_id bigint not null references public.users(id) on delete cascade,
  name text not null,
  line text not null,
  history text not null,
  curiosities text,
  created_at timestamptz not null default now()
);

-- SPIRITUAL ENTITIES --------------------------------------------------------
create table if not exists public.spiritual_entities (
  id bigint generated by default as identity primary key,
  name text not null,
  line text not null,
  description text not null,
  description_history jsonb not null default '[]'::jsonb,
  created_at timestamptz not null default now()
);

-- LORE ----------------------------------------------------------------------
create table if not exists public.lore_entries (
  id bigint generated by default as identity primary key,
  title text not null,
  content text not null,
  related_entities bigint[] not null default '{}',
  created_at timestamptz not null default now()
);

-- RPC: append spiritual entity history -------------------------------------
create or replace function public.append_spiritual_entity_history(
  entity_id bigint,
  description text
) returns void
language plpgsql
security definer
as $$
begin
  update public.spiritual_entities
  set description_history = coalesce(description_history, '[]'::jsonb) || jsonb_build_object(
    'timestamp', now(),
    'description', description
  )
  where id = entity_id;
end;
$$;

-- BASIC POLICIES ------------------------------------------------------------
-- Enable Row Level Security and allow anonymous access. Adjust according to your auth strategy.

alter table public.events enable row level security;
alter table public.announcements enable row level security;
alter table public.prayer_requests enable row level security;
alter table public.gallery_images enable row level security;
alter table public.users enable row level security;
alter table public.diary_entries enable row level security;
alter table public.recados enable row level security;
alter table public.member_entities enable row level security;
alter table public.spiritual_entities enable row level security;
alter table public.lore_entries enable row level security;

do $$
begin
  if not exists (select 1 from pg_policies where tablename = 'events' and policyname = 'events_read') then
    create policy events_read on public.events for select using (true);
    create policy events_write on public.events for all using (true) with check (true);
  end if;
  if not exists (select 1 from pg_policies where tablename = 'announcements' and policyname = 'announcements_read') then
    create policy announcements_read on public.announcements for select using (true);
    create policy announcements_write on public.announcements for all using (true) with check (true);
  end if;
  if not exists (select 1 from pg_policies where tablename = 'prayer_requests' and policyname = 'prayer_requests_read') then
    create policy prayer_requests_read on public.prayer_requests for select using (true);
    create policy prayer_requests_write on public.prayer_requests for all using (true) with check (true);
  end if;
  if not exists (select 1 from pg_policies where tablename = 'gallery_images' and policyname = 'gallery_images_read') then
    create policy gallery_images_read on public.gallery_images for select using (true);
    create policy gallery_images_write on public.gallery_images for all using (true) with check (true);
  end if;
  if not exists (select 1 from pg_policies where tablename = 'users' and policyname = 'users_read') then
    create policy users_read on public.users for select using (true);
    create policy users_write on public.users for all using (true) with check (true);
  end if;
  if not exists (select 1 from pg_policies where tablename = 'diary_entries' and policyname = 'diary_entries_read') then
    create policy diary_entries_read on public.diary_entries for select using (auth.uid() is not null);
    create policy diary_entries_write on public.diary_entries for all using (auth.uid() is not null) with check (auth.uid() is not null);
  end if;
  if not exists (select 1 from pg_policies where tablename = 'recados' and policyname = 'recados_read') then
    create policy recados_read on public.recados for select using (auth.uid() is not null);
    create policy recados_write on public.recados for all using (auth.uid() is not null) with check (auth.uid() is not null);
  end if;
  if not exists (select 1 from pg_policies where tablename = 'member_entities' and policyname = 'member_entities_read') then
    create policy member_entities_read on public.member_entities for select using (true);
    create policy member_entities_write on public.member_entities for all using (true) with check (true);
  end if;
  if not exists (select 1 from pg_policies where tablename = 'spiritual_entities' and policyname = 'spiritual_entities_read') then
    create policy spiritual_entities_read on public.spiritual_entities for select using (true);
    create policy spiritual_entities_write on public.spiritual_entities for all using (true) with check (true);
  end if;
  if not exists (select 1 from pg_policies where tablename = 'lore_entries' and policyname = 'lore_entries_read') then
    create policy lore_entries_read on public.lore_entries for select using (true);
    create policy lore_entries_write on public.lore_entries for all using (true) with check (true);
  end if;
end;
$$;
